<!DOCTYPE html>
<head></head>
<body>

  <script>
    let tempObj = { name: "call", a: 2};
    function func(c, d) {
      console.log(this,"this")
      console.log(c+d+this.a,"a");
    }
    func();
    func.call(tempObj);
    // 总的原理 就是在你需要的对象上添加这个函数
    //  content.fn = this { this指向的就是你绑定的函数 个人觉得就是原型中的construct 类似类似}
    //  执行content.fn  可以使用eval 
    //  删除content 上面的fn delete fn

    // call 原理
    Function.prototype.myCall = function(context){
      let content = context || window;
      console.log(this,"thiscall")
      content.fn = this;
      let args = [];
      console.log(arguments,"agr");
      for(let i=1, len = arguments.length;i < len; i++) {
        args.push('arguments[' + i + ']');
      }
      console.log(...args, "agrs");
      let result = eval('content.fn('+ args+')');
      delete content.fn;
      return result;
    }
    func.myCall(tempObj,3,4);
    // apply 原理
    Function.prototype.myApply = function(context) {
      let content = context || window;
      content.fn = this;
      let args = arguments[1];
      // let result = eval("content.fn("+args+")");
      // let that = this;
      let result = content.fn(...args); 
      delete content.fn;
      return result
    };
    let applayObj = { a: 1};
    function applayFun (b, c) {
      console.log(this.a , b , c,"abc");
    }
    applayFun.myApply(applayObj, [3,5]);
    // bind的原理 返回一个函数 但是不会执行
    // Function.prototype.myBind = function(context) {
    //   let content = context || window;
    //   content.fn = this;
    //   let args = Array.from(arguments).slice(1)
    //   console.log(args, "args")
    //   return content.fn(...args)
    // }
    // let bindObj = { a: 10};
    // function bindFun (b,c) {
    //   console.log(this.a + b + c, "bind")
    // }
    // let bindChange = bindFun.myBind(bindObj, 5, 6);
    // bindChange();
  </script>
</body>
</html>